IMPORTANT COMANDS:
    container-name: python-django

    docker build --tag {container-name} .
    https://docs.docker.com/reference/cli/docker/image/build/

    docker run -- publish 8000:8000 {container-name}
    https://docs.docker.com/reference/cli/docker/container/run/

    ---

    docker-compose build
    https://docs.docker.com/reference/cli/docker/compose/build/

    docker-compose up
    https://docs.docker.com/reference/cli/docker/compose/up/

    --- Basic Commands

    docker ps 
    list current containers

    docker exec {container-name} <your command>
    for example, you want migrations in you already running container:
        docker exec python-django python manage.py migrate

    docker exec -it django_app /bin/bash 
    with this you can get into shell

    in alpine (and most of the distros) it is:
    docker exec -it django_app sh


TODO:
    - convert database to postgres from sqllite

TEST:
    
What is what?

    Dockerfile -> our docker image file
    docker-compose -> its a tech that allows us to use multiple images at once "docker-compose.yml" is our config


IMPORTANT NOTES:

    You can use "redis" tag as your redis image in docker-compose. It is alphine version of redis which is small and fast. But you can also use "redis:bookworm" tag which is debian redis. It is larger but uses debian's security and stability quarantees.

    In celery service we used an important feature. restart is really good in case of down important services. It tries it's best to restart the whole service in case it's down.
    Here is multiple options for this feature: 
    https://docs.docker.com/config/containers/start-containers-automatically/#use-a-restart-policy
